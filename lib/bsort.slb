;   Copyright (C) 2015, Pascal Niklaus pascal@niklaus.org
;
;   This file is part of the CPIK library
;   ----------------------------------------------------------------------- 
;   This library is free software; you can redistribute it and/or modify it
;   under the terms of the GNU General Public License as published by the
;   Free Software Foundation; either version 2.1, or (at your option) any
;   later version.
 
;   This library is distributed in the hope that it will be useful,
;   but WITHOUT ANY WARRANTY; without even the implied warranty of
;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;   GNU General Public License for more details.
 
;   You should have received a copy of the GNU General Public License 
;   along with this library; see the file COPYING. If not, write to the
;   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
 
;   As a special exception, if you link this library with other files,
;   some of which are compiled with CPIK, to produce an executable,
;   this library does not by itself cause the resulting executable to
;   be covered by the GNU General Public License. This exception does
;   not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.


;   VERSION 0.1
;
;   HISTORY
;   - Created 26-02-2015 by P. Niklaus
;
;   CONTENTS
;
;   C18_bsort
;
;   ----------------------------------------------------------------------- 

; Bubble sort
;
; Implementation of the bubble sort algorithm for arbitrary structures with
; up to 127 bytes in element size. 
; This algorithm is very basic and has a very small memory footprint.
; However, it scales poorly with array size and therefore should only be used
; for small arrays or when execution time is not critical.
;                
; void bsort(void *data, size_t length, unsigned char size, char *(cmpfun)(void *e1, *e2), )
;
; data:   address of first array element
; length: number of elements in array
; size:   size of a single element (1..127 bytes)
; cmpfun: function returning a value>0 if e1>e2 
;
; 146 bytes
:
; register use: 
;   FSR1  *data (incremented in inner loop)
;   R0    cmp function result
;   R0+1  temporary (swapping, addition)
;   R1    swap flag (1=data swapped)
;   FSR2  loop counter (size-1 .. 0)
;
; Stack: 
; -6  cmpfuncL
; -5  cmdfuncH
; -4  size
; -3  lengthL
; -2  lengthH
; -1  dataL
;  0  dataH
;  1  R1 (swap flag)
;  2  FSR2L (loop counter)
;  3  FSR2H
;  4  e1L
;  5  e1H
;  6  e2L
;  7  e2H
;<+C18_bsort>
C18_bsort        
L18_bsort_outerloop        
        clrf    R1,0            ; clear swap flag
        movlw   -3
        movff   PLUSW0,FSR2L    ; FSR2 = loop counter = length
        movlw   -2
        movff   PLUSW0,FSR2H  
        movf    POSTDEC2,F,0    ; FSR2--

        movlw   -1
        movff   PLUSW0,FSR1L    ; FSR1 = start of array
        movff   INDF0,FSR1H 
        
L18_bsort_innerloop        
        movf    POSTDEC2,0      ; FSR2--
        btfsc   FSR2H,3,0       ; FSR2<0? (FSR2=0x0fff on wrap-around)
        IBRA    L18_bsort_innerloop_end
        
        movlw   -4
        movff   PLUSW0,R0+1     ; element size

        ; --- save loop data to be preserved on stack
        movff   R1,PREINC0      ; save R1 on stack
        movff   FSR2L,PREINC0   ; save FSR2 (counter) on stack
        movff   FSR2H,PREINC0    
        
        ; --- push function arguments on stack (e1, e2=e1+size)
        movf    FSR1L,W,0       ; pointer to 1st element        
        movwf   PREINC0,0       ;   push e1 low
        addwf   R0+1,W,0        ;     add element size
        movff   FSR1H,PREINC0   ;   push e1 high          
        movwf   PREINC0,0       ;   push e2 low
        movf    FSR1H,W,0          
        btfsc   STATUS,C,0      ;     did carryover happen
        addlw   1
        movwf   PREINC0,0       ;   push e2 high

        ; --- indirect call
        movlw   -6-7               
        movff   PLUSW0,PREINC0    ; move function ptr low byte
        movff   PLUSW0,PREINC0    ; move function ptr high byte        
        ICALL   indirect_call
        
        ; --- clean stack and restore FSR1 
        movf    POSTDEC0,0
        movf    POSTDEC0,0
        movf    POSTDEC0,FSR1H,0
        movf    POSTDEC0,FSR1L,0        
        
        ; --- restore loop data from stack
        movff   POSTDEC0,FSR2H
        movff   POSTDEC0,FSR2L    ; restore FSR2 (counter) from stack
        movff   POSTDEC0,R1       ; restore R1 (swap flag) from stack
                 
        movlw   -4
        movf    PLUSW0,W,0        ; size        

        ; --- check comparison result
        comf    R0,F,0
        bn      L18_bsort_dont_swap
                
        ; --- swap data
L18_bsort_swap        
        movwf   R0,0              ; counter & offset (PLUSW1) are equal
L18_bsort_swap_loop               ; swap & FSR1 += size
        movff   PLUSW1,R0+1
        movff   INDF1,PLUSW1
        movff   R0+1,POSTINC1        
        
        decf    R0,F,0
        bnz     L18_bsort_swap_loop        
        
        bsf     R1,1,0            ; set swap flag        
        IBRA    L18_bsort_innerloop                
        
L18_bsort_dont_swap               ; FSR1 += size
        addwf   FSR1L,F,0         ;   W contains size
        btfsc   STATUS,C        
        incf    FSR1H,F,0       
        IBRA    L18_bsort_innerloop                                     
        
L18_bsort_innerloop_end
        movf    R1,W,0            ; swap flag set?
        bnz     L18_bsort_outerloop ;yes, repeat
        return  0
X18_bsort                
;<?indirect_call>        
;<->
        