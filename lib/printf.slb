;   Copyright (C) 2016, Pascal Niklaus pascal@niklaus.org
;
;   This file is part of the CPIK library
;
;   This library is free software. You can redistribute it and/or
;   modify it under the terms of the GNU General Public License as
;   published by the Free Software Foundation; either version 2.1, or
;   (at your option) any later version.
; 
;   This library is distributed in the hope that it will be useful,
;   but WITHOUT ANY WARRANTY; without even the implied warranty of
;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;   GNU General Public License for more details.
; 
;   You should have received a copy of the GNU General Public License 
;   along with this library; see the file COPYING. If not, write to the
;   Free Software Foundation, 51 Franklin Street, Fifth Floor, Boston,
;   MA 02110-1301, USA.
; 
;   As a special exception, if you link this library with other files,
;   some of which are compiled with CPIK, to produce an executable,
;   this library does not by itself cause the resulting executable to
;   be covered by the GNU General Public License. This exception does
;   not however invalidate any other reasons why the executable file
;   might be covered by the GNU General Public License.
;
;
;   ======================= PRINTF FOR CPIK ============================

;   VERSION 0.1
;
;   HISTORY
;   - Created 17-01-2016 by P. Niklaus
;
;   ====================================================================
;
;   CONTENTS
;
;   printf for CPIK, with format string in one of the following formats:
;   a) embedded in code (ROM), b) in ROM, using an accessor function, c) in RAM
;
;   C HEADER DEFINITIONS:
;
;   Different functions are provided depending on the location of the format
;   strings. For technical reasons (ROM storage of format string), the printf
;   family or functions is implemented as macros that invoke functions defined
;   in this assembly code file:
;
;   /* Macros (invoked by user) */
;
;   #define printf( fmt, ... ) \
;       get_ROM_ptr_(); \
;       __datat__(fmt); \
;       __datat__("\0"); \
;       printf_(0u, __VA_ARGS__);
;
;   #define RFprintf( fmt, ... ) \
;       printf_(2u, fmt, __VA_ARGS__);
;
;   #define RAMprintf( fmt, ... ) \
;       printf_(1u, fmt, __VA_ARGS__);
;
;   /* functions invoked only via macros */
;
;   unsigned char printf_(uint8_t dummy,...) ;
;   void get_ROM_ptr_();
;
;   USAGE:
;
;   Although implemented as macro, the printf functions can be used as if they
;   were regular functions, e.g.:
;
;   printf("f=%10.3f i=%+3d s=%8s",1.234,12,"foo").
;
;   char RAMstring[] = "i=%d";
;   RAMprintf(RAMstring,123);
;
;   ROMF_TXT(accessor, "i=%d\0")
;   RFprintf(accessor,123);
;
;   MEMORY FOOTPRINT
;
;    732 ROM and 11 (static) RAM bytes without float support
;   1226 ROM and 15 (static) RAM bytes with float support
;
;   SUPPORTED DATA FORMATS
;
;   INTEGERS
;
;   %d        signed integers, decimal
;   %u        unsigned integers, decimal
;   %x        unsigned integers, hexadecimal
;   %X        as %x, but letters capitalized
;   %o        unsigned integers, octal
;   %b        unsigned integers, binary
;
;   Format modifiers for integer data:
;   l,ll      for long (16bits) and long long (32bits) data
;   n         field width
;   n.nn      as above, but decimal point injected after nn digits from right
;             this is very useful when working with fixed decimal numbers
;   +         always print sign ('+' or '-')
;  ' '        space; print space for positive numbers, '-' for negative ones
;   0         left-pad to field width with leading zeroes, leaving space for
;             the sign character ('+', '-' or ' ', or nothing for positive
;             numbers when no ' ' or '+' was specified)
;
;   32bit FLOATS
;
;   %f        fixed decimal format (e.g. 123.456)
;   %e        exponential format   (e.g. 1.234E+02)
;   %g        not implemented yet, defaults to %e
;
;   Format modifiers for float data
;
;   n         total field width (incl. E+XX in %e)
;   .n        number of post-decimal digits
;   +,-,SPACE sign format, as for integer data
;   0         pad leading space with zeroes
;
;   CHARS, STRINGS
;
;   %c        print single char
;   %s        print string
;
;   Format modifiers for strings
;
;   n         field width
;   -         left-justified
;
;   POINTERS
;
;   %p        pointers are treated like 16bit hexadecimals, except
;             that 3 digits are printed by default and that they
;             are preceeded by a leading '0x'
;
;   IMPLEMENTATION DETAILS
;
;   Format strings are parsed for their components, not checking for
;   bogus information.
;
;   To keep the memory footpring low, the floating point part is implemented
;   linking only float multiplication and addition routines, plus the conversion
;   of float to a 32bit unsigned integer. This results in some limitations,
;   which, however, are not of practical relevance if known.
;
;   Floating point output is produced by handling the mantissa as unsigned
;   32bit integer that is obtained by repeated multiplication with 10 or 0.1.
;
;   This has two consequences: First, only about 8 significant digits
;   can be printed; a higher number will result in an overflow in the integer
;   arithmetic, which is detected and signalled by filling the respective
;   field with asterisks. Second, repeated multiplication will accumulate
;   small arithmetic errors, potentially biasing the last digits.
;   For example, the number 12345678.9 can be printed as %.2f (resulting
;   in 12345679.36; the last digits exceed float precision, but the number
;   1234567936 is still representable as 32bit unsigned). In contrast, the
;   same number will result in overflow and print as '*' with %.3f format,
;   because 12345678900 exceeds the 32bit integer range.
;
;   For the exponential format (%e), the number of digits is limited to 8
;   even if more are requested. This really is already more than the precision
;   of the single precision float. So specifying %.10 will nevertheless
;   print only 7 post-decimal digits.
;
;   Although I never encountered this, there is the possibility of rounding
;   errors that could lead to printing of numbers very close to an integer
;   power of 10 with a mantiassa not in the [1,10[ range. The printed number
;   will still be correct (apart form the rounding error). For example, 1000
;   could print as 10.0000E+02 or 0.9999E+3 in such cases. This might be
;   fixed in future releases.
;
;   EXAMPLES FORMATS AND OUTPUT
;
;   %5d      "  123"                   %-5d    "123  "
;   %05d     "00123" "-0123"           % 05d   " 0012" "-0012"
;   %+5d     " +123" " -123"           %016b   "0111000010101010"
;   %08llx   "deadbeef"                %04o    "0577"
;   %6.2d    " 12.34" (with argument 1234)
;   %p       "0x3ff"                   %c      "a"
;   %+8.2f   " +123.45"                %8.3e   "1.23E+02"
;   %-8.2f   "123.45  "                %+9.3e  "+1.23E+02"
;   %s       "string"                  %10s    "    string"
;   %-10s    "string    "
;
;   ROUTINGES DEFINED (invoked via macro, not to be called directly)
;
;   C18_printf_
;   C18_printf_get_fmt_ptr_

; =============================================================================

;
; printf_

; Register use:
;
; TBLPTR is used and *not* preserved. This might be fixed changed in future
; versions but should not cause any problems.

; ------------------------------------------------------------
;
; STACK FRAME
;
; ARGN  arguments, type-specific (LO->HI ORDER)
; ...
; ARG2
; ARG1
; dummy                  <- FSR0 upon call, dummy is discarded

;; -------------------- static RAM locations --------------------------------

;; printf uses some static RAM locations... Implementing these
;; variables in a stack frame would have been complicated given
;; the variable number of arguments, and resulted in much larger
;; code. RAM use is 8 bytes + 4 extra bytes for float support.

;<+L18_pf_static|UDATA>
        CBLOCK
        L18_pf_outch_vec:2                      ; putchar vector
        L18_pf_initial_FSR0:2                   ; stack pointer backup (_VA_ARG_ stuff)        
        L18_pf_FMTMODE:1                        ; format mode (0=ROM, 1=ROM ACCESSOR, 2=RAM, 4=ROM PTR)   
        L18_pf_FMTPTR:2                         ; format ptr area, for RAM pointer
        L18_pf_STRPTR:2                         ; string pointer for sprintf
        L18_pf_sign:1                           ; 0: pos, ff:neg                               
        L18_pf_totlen:1                         ; total # of characters printed                  
        ENDC
;<->

;<+L18_pf_static_float|UDATA>
        CBLOCK
        L18_pf_opts:1                           ; bits: 7:+ 6:space 5:- 4:. 3:caps 2:0 0..1:# of l 
        L18_pf_curlen:1                         ; # of characters printed in current field
        L18_pf_fw:1                             ; field width specified
        L18_pf_prec:1                           ; precision (digits after '.')
        ENDC
;<->

;; -------------------- C18_printf_ exit & error handling --------------------

;; typedef void (*printf_putch_fun)(char);
;; printf_putch_fun printf_set_putch(printf_putch_fun vec);

;<+C18_printf_set_putch>
C18_printf_set_putch
        movff   L18_pf_outch_vec,_r0            ; return old vector
        movff   L18_pf_outch_vec+1,_r0+1
        movff   INDF0,L18_pf_outch_vec+1        ; set new vector
        movlw   -1
        movff   PLUSW0,L18_pf_outch_vec       
        return  0
X18_printf_set_putch        
;<?L18_pf_static>
;<->

;; -------------------- C18_printf_ exit & error handling --------------------

;; unsigned char printf_chars_printed();
;; get number of characters printed by last printf call. This function is useful
;; since the macro-invoked printf calls cannot directly return a value.

;<+C18_printf_chars_printed>
C18_printf_chars_printed
        movff   L18_pf_totlen,_r0
        return  0
;<?L18_pf_static>
;<->

;; -------------------- C18_printf_ exit & error handling --------------------

;<+C18_printf_>

;; ---------- enable (1) or disable (0) floating point support

PRINTF_FLOATS   equ     1                       ; enable FLOAT code

;; ---------- access page variable aliases

;; these store infos during processing of individuals format fields
;; during float printing, these are copied to static ram locations

PF_CURLEN       equ     _r5+1
PF_FW           equ     _r5
PF_PREC         equ     _r4+1
PF_OPTS         equ     _r4

;; ---------- bits in PF_OPTS

PF_OPT_PLUS     equ     7                       ; '+' in format string
PF_OPT_SPC      equ     6                       ; ' ' in format string
PF_OPT_MINUS    equ     5                       ; '-' in format string
PF_OPT_DOT      equ     4                       ; '.' in format string
PF_OPT_CAPS     equ     3                       ; 'X' in format string (capitalize hex letters)
PF_OPT_LEAD0    equ     2                       ; '0' leading 0 in format string
PF_OPT_MSK_NUML equ     0x03                    ; number of l (long) modifiers, 0..2

;; -------------------- C18_printf_nextbyte --------------------
;;
;; get next byte of format string, with methods depending on
;; the "mode" code (RAM, ROM, ROM accessor)

L18_pf_nextbyte
        movff   L18_pf_FMTMODE,WREG             ; determine mode
        andlw   0x01
        bnz     L18_pf_RAM
L18_pf_ROM                                      ; read next byte from ROM 
        tblrd*+                                 
        movf    TABLAT,W,0
        return  0
L18_pf_RAM                                      ; read next byte from RAM
        movff   L18_pf_FMTPTR,FSR2L             ; FSR2 *not* saved
        movff   L18_pf_FMTPTR+1,FSR2H           
        movf    POSTINC2,W,0
        movff   FSR2L,L18_pf_FMTPTR             
        movff   FSR2H,L18_pf_FMTPTR+1           
        return  0
               
;; -------------------- C18_printf_end --------------------
;;
;; exit C18_printf_, restoring stack pointer to orignal value,
;; regardless where it currently is

L18_pf_invalid_fmt                              ; illegal format string, exit
L18_pf_end
        lfsr    1,L18_pf_FMTMODE
        btfss   INDF1,7,0
        bra     L18_pf_end_not_sprintf
        movff   L18_pf_STRPTR,FSR1L             ; sprintf: NUL-terminate string
        movff   L18_pf_STRPTR+1,FSR1H
        clrf    INDF1,0
L18_pf_end_not_sprintf        

        movlw   ~((1<<GIEH)|(1<<GIEL))          ; block interrrupts
        andwf   INTCON,F,0

        movff   L18_pf_initial_FSR0,  FSR0L     ; restore stack pointer
        movff   L18_pf_initial_FSR0+1,FSR0H
        
        movf    _it_mask,W,0                    ; re-set previous interrupt state
        iorwf   INTCON,F,0

        movff   L18_pf_totlen,_r0               ; return # of chars printed
        return  0

;; -------------------- C18_printf_ entry  --------------------

C18_printf_
        movff   FSR0L,L18_pf_initial_FSR0       ; backup stack ptr - allows safe
        movff   FSR0H,L18_pf_initial_FSR0+1     ;   exiting from anythere
        movf    POSTDEC0,W,0                    ; format string location (RAM, ROM)
        movff   WREG,L18_pf_FMTMODE             ; store mode
        btfss   WREG,7,0                        ; "s"printf?
        bra     L18_printf_no_sprintf
L18_printf_sprintf
        movff   POSTDEC0,L18_pf_STRPTR+1        ; string for sprintf
        movff   POSTDEC0,L18_pf_STRPTR          ; string for sprintf
L18_printf_no_sprintf
        andlw   0x7f                            ; mask out sprintf bit
        bz      L18_printf_embedded_fmt         ; embedded ROM data
        andlw   0x03
        bnz     L18_printf_RAM_RF               ; format in RAM or ROM accessor
L18_printf_RP                                   ; format is ROM pointer        
        clrf    TBLPTRU,0                       ; copy ROM pointer to TBLPTR
        movff   POSTDEC0,TBLPTRH
        movff   POSTDEC0,TBLPTRL
        bra     L18_printf_embedded_fmt 
L18_printf_RAM_RF
        andlw   0x01
        bnz     L18_printf_RAM
L18_printf_RF                                   ; ROM accessor
        clrf    PREINC0,0                       ; index
        movlw   -2
        movff   PLUSW0,PREINC0                  ; copy ROM accessor
        movff   PLUSW0,PREINC0
        ICALL   indirect_call                   ; call ROM accessor, TBLPTR points to 1st char now
        movf    POSTDEC0,W,0
        movf    POSTDEC0,W,0
        movf    POSTDEC0,W,0        
        bra     L18_printf_embedded_fmt 
L18_printf_RAM
        movff   POSTDEC0,L18_pf_FMTPTR+1        ; high byte of ptr (RAM)
        movff   POSTDEC0,L18_pf_FMTPTR          ; low byte of ptr
        movlw   0
        movff   WREG,L18_pf_FMTPTR+2            ; ROM accessor: index=0; not used for RAM
L18_printf_embedded_fmt
        lfsr    1,L18_pf_totlen                 ; total number of characters printed = 0
        clrf    INDF1,0
        
;; -------------- iterate through format string --------------------

L18_pf_loop
        rcall   L18_pf_nextbyte            
        andlw   0xff
        bz      L18_pf_end                      ; NUL reached
        xorlw   '%'
        bz      L18_pf_pct        
L18_pf_pct_pct
        xorlw   '%'                             ; restore W        
        ICALL   L18_pf_outch
        bra     L18_pf_loop
        
L18_pf_pct
        rcall   L18_pf_nextbyte
        xorlw   '%'
        bz      L18_pf_pct_pct
        xorlw   '%'                             ; not '%', restore
        clrf    PF_CURLEN,0                     ; # of chars printed in *this* field
        clrf    PF_FW,0                         ; field width
        clrf    PF_PREC,0                       ; precision
        clrf    PF_OPTS,0                       ; options
        lfsr    1,L18_pf_sign                   ; set sign positive even if not 
        clrf    INDF1,0                         ; used for all data types        
        bra     L18_pf_fmt_enter

        ; ----------------------- parse format specifier -----------------------

L18_pf_fmt_loop
        rcall   L18_pf_nextbyte
L18_pf_fmt_enter
        movwf   _r0,0
        andlw   0xff                            
        bz      L18_pf_end                      ; end of fmt found -- illegal format

        ; --------------------- check for format modifiers ---------------------

        xorlw   'l'   
        bz      L18_pf_fmt_l
        xorlw   'l'^'+'
        bz      L18_pf_fmt_plus
        xorlw   '+'^' '
        bz      L18_pf_fmt_spc
        xorlw   ' '^'-'
        bz      L18_pf_fmt_minus
        xorlw   '-'^'.'
        bz      L18_pf_fmt_dot
        xorlw   '.'                             ; restore W and check if ['0','9']
        addlw   255 - '9'
        addlw   ('9'-'0') + 1
        bc      L18_pf_fmt_digit

        ; ------------------- check for data type qualifiers ---------------------

        movf    _r0,W,0
        xorlw   'c'
        bz      L18_pf_char
        xorlw   'c'^'d'
        bz      L18_pf_int
        xorlw   'd'^'i'
        bz      L18_pf_int
        xorlw   'i'^'u'
        bz      L18_pf_uint
        xorlw   'u'^'x'
        bz      L18_pf_hex
        xorlw   'x'^'X'
        bz      L18_pf_HEX
        xorlw   'X'^'p'
        bz      L18_pf_HEX
        xorlw   'p'^'b'
        IBZ     L18_pf_bin
        xorlw   'b'^'o'
        IBZ     L18_pf_oct
        xorlw   'o'^'s'
        IBZ     L18_pf_string
IF PRINTF_FLOATS > 0        
        xorlw   's'^'f'
        IBZ     L18_pf_float_f
        xorlw   'f'^'e'
        IBZ     L18_pf_float_e
        xorlw   'e'^'g'
        IBZ     L18_pf_float_g
ENDIF        
        bra     L18_pf_invalid_fmt              ; illegal format -> exit

        ; -------------------- handle format modifiers -------------------------

L18_pf_fmt_l
        incf    PF_OPTS,1,0                     ; count # of 'l's, no need
        bra     L18_pf_fmt_loop                 ;   to protect upper bits
L18_pf_fmt_plus
        bsf     PF_OPTS,PF_OPT_PLUS,0           ; '+' found (e.g. %+3d)
        bra     L18_pf_fmt_loop
L18_pf_fmt_spc
        bsf     PF_OPTS,PF_OPT_SPC,0            ; ' ' found (e.g. % 3d)
        bra     L18_pf_fmt_loop
L18_pf_fmt_minus
        bsf     PF_OPTS,PF_OPT_MINUS,0          ; '-' found (e.g. %-10s)
        bra     L18_pf_fmt_loop
L18_pf_fmt_dot
        bsf     PF_OPTS,PF_OPT_DOT,0            ; '.' found (e.g %6.2f)
        bra     L18_pf_fmt_loop
L18_pf_fmt_digit
        ; digit processing relies on PF_FW following immediately after PF_PREC
        ; generate error if this is the case
        IF PF_FW-PF_PREC != 1
        ERROR "PF_FW needs to follow PF_PREC"
        ENDIF
        movwf   _r0,0                           ; save number
        lfsr     1,PF_FW                        ; default = field width
        btfsc   PF_OPTS,PF_OPT_DOT,0            ; was '.' already encountered?
        decf    FSR1L,1,0                       ; yes -> point to precision (PF_PREC)
        movf    INDF1,W,0                       ; get old number
        mullw   10                              ; multiply by 10
        movf    PRODL,W,0
        addwf   _r0,0,0                         ; add new digit
        bnz     L18_pf_fmt_digit_cont
        btfss   PF_OPTS,PF_OPT_DOT,0            ; don't detect leading 0 in precision field
        bsf     PF_OPTS,PF_OPT_LEAD0,0          ; leading zero in field widt -> flag
L18_pf_fmt_digit_cont
        movwf   INDF1,0                         ; store result
        bra     L18_pf_fmt_loop

;; ----------------------- print char --------------------------

L18_pf_char                                     ; print single character
        movf    POSTDEC0,W,0
        rcall   L18_pf_outch
        bra     L18_pf_loop

;; ------------------ string ----------------------------

L18_pf_string
        ICALL   popPTR                          ; ptr to string -> FSR1
        movlw   -1
        btfsc   PF_OPTS,PF_OPT_MINUS,0          ; '-' flag
        bra     L18_pf_string_minus
        movlw   -1                              ; determine string length
L18_pf_string_len_loop
        addlw   1
        tstfsz  PLUSW1,0
        bra     L18_pf_string_len_loop
        addwf   PF_CURLEN,1,0                   ; pretend string already printed
        rcall   L18_pf_pad_space
L18_pf_string_minus
L18_pf_spool_RAM_string
        movf    POSTINC1,W,0                    ; check for stop mark
        bz      L18_pf_spool_RAM_string_end
        movff   FSR1L,PREINC0
        movff   FSR1H,PREINC0
        rcall   L18_pf_outch
        movff   POSTDEC0,FSR1H
        movff   POSTDEC0,FSR1L
        bra     L18_pf_spool_RAM_string
L18_pf_spool_RAM_string_end
        rcall   L18_pf_pad_space
        bra     L18_pf_loop

;; ------------------ signed integer ----------------------------

L18_pf_int
        btfsc   PF_OPTS,1,0                     ; fetch signed formats from 
        bra     L18_pf_s32bits                  ;   stack and expand to 32 bit
        btfsc   PF_OPTS,0,0
        bra     L18_pf_s16bits
        
L18_pf_s8bits
        ICALL   cast8_32
        bra     L18_pf_s32bits

L18_pf_s16bits
        ICALL   cast16_32

L18_pf_s32bits
L18_pf_int_cont
        btfss   INDF0,7,0                       ; negative?
        bra     L18_pf_int_is_positive
L18_pf_int_is_negative
        ICALL   neg32                           ; reverse sign
        lfsr    1,L18_pf_sign
        setf    INDF1,0                         ; flag as negative
L18_pf_int_is_positive
        movlw   10
        movwf   _r0,0                           ; base 10
        bra     L18_pf_u32bits

; -------------------- unsigned integer --------------------
; (and variants with base other than 10)

L18_pf_bin
        movlw   2                               ; binary = base 2
        bra     L18_pf_uint_cont
L18_pf_oct
        movlw   8                               ; octal = base 8
        bra     L18_pf_uint_cont
L18_pf_HEX
        bsf     PF_OPTS,PF_OPT_CAPS,0           ; flag that printing in capitals
L18_pf_hex
        movlw   16                              ; hex = base 16
        bra     L18_pf_uint_cont
L18_pf_uint
        movlw    10                             ; decimal = base 10
L18_pf_uint_cont
        movwf   _r0,0                           ; store base in _r0
        btfsc   PF_OPTS,1,0                     ; pop from stack, expand to 32 bits
        bra     L18_pf_u32bits
        btfsc   PF_OPTS,0,0
        bra     L18_pf_u16bits
L18_pf_u8bits
        clrf    PREINC0,0
L18_pf_u16bits
        clrf    PREINC0,0
        clrf    PREINC0,0
L18_pf_u32bits
        movff   FSR0L,FSR1L                     ; point FSR1 to 32bit data
        movff   FSR0H,FSR1H 
        movf    POSTDEC1,W,0
        movf    POSTDEC1,W,0
        movf    POSTDEC1,W,0

        clrf    PREINC0,0                       ; push stop mark, digit chars will follow
   
        rcall   L18_pf_print_uint32_fsr1        ; push digit chars
        
        movf    POSTDEC0,W,0                    ; remove data from stack
        movf    POSTDEC0,W,0
        movf    POSTDEC0,W,0
        movf    POSTDEC0,W,0

        bra     L18_pf_loop

; --------------------- print pointer --------------------------

L18_pf_ptr
        movlw   '0'
        rcall   L18_pf_outch
        movlw   'x'
        rcall   L18_pf_outch
        movlw   1+4                             ; 16bit format
        movwf   PF_OPTS,0
        movf    PF_FW,W,0                       ; is width specified?
        bnz     L18_pf_ptr_go
        movlw   5                               ; no, use default width
        movwf   PF_FW,0
L18_pf_ptr_go
        bra     L18_pf_hex                      ; go to regular hex printing

;; ------------------------- print 32 bit uint ----------------------------

;; print 32bit unsigned int pointed to by FSR1
;; field width (PF_FW), options (PF_OPTS), and precision (PF_PREC) must be set
;; base (e.g. 10 for decimal) must be in _r0
;; there must be a stop mark (0) already on the stack
;; upon exit, all data incl. stop mark will be removed

L18_pf_print_uint32_fsr1       

        rcall   L18_pf_div_by_base_and_push

        ; ---- determine specific format type

        btfsc   PF_OPTS,PF_OPT_LEAD0,0            ; test if '0' in format
        bra     L18_pf_sign_zero_digits
        btfsc   PF_OPTS,PF_OPT_MINUS,0            ; test if '-' in format
        bra     L18_pf_sign_digits_pad
        movf    PF_FW,W,0                         ; field width
        bnz     L18_pf_pad_sign_digits

L18_pf_sign_digits_pad
        rcall   L18_pf_outsign
        rcall   L18_pf_spool
        bra     L18_pf_pad_space

L18_pf_sign_zero_digits
        rcall   L18_pf_outsign
        rcall   L18_pf_calc_pad_size_no_sign
        rcall   L18_pf_pad_zeroes
        bra     L18_pf_spool

L18_pf_pad_sign_digits
        rcall   L18_pf_calc_pad_size
        rcall   L18_pf_pad_space
        rcall   L18_pf_outsign
        bra     L18_pf_spool


;; ----------------------- float exp format (%f) --------------------

;; algorithm for %f:
;; - multiply by 10^precision
;; - add 0.5 for rounding
;; - convert to uint32
;; - check for overflow
;; - print with decimal inserted

IF PRINTF_FLOATS > 0

L18_pf_float_f                                  ; FSR0 points to last byte
        rcall   L18_pf_float_handle_sign_r45    ; float on stack -> f1, set sign flags, save _r4.._r5+1
        movff   PF_PREC,PREINC0                 ; push precision == loop counter

L18_pf_float_f_loop                             ; multiply by 10^precision
        decf    INDF0,F,0
        bn      L18_pf_float_f_loop_end

        rcall   L18_pf_f2ten
        ICALL   zfpmul32
        bra     L18_pf_float_f_loop
L18_pf_float_f_loop_end
        movf    POSTDEC0,W,0                    ; pop counter
        rcall   L18_pf_f2half
        ICALL   zfpadd32

        movlw   0x4f                            ; if value > 4f7fffff (== 4294967040) -> overflow
        subwf   _f1+3,W,0                       ; byte 3 > 0x4f --> err
        bn      L18_pf_float_f_range_ok         ; byte 3 < 0x4f --> ok
        bz      L18_pf_float_f_range_chk2       ; byte 2, bit 7 set -> err
        
L18_pf_float_f_overflow
        rcall   L18_pf_restore_r                ; restore r4..r5+1
        decf    PF_FW,F,0
L18_pf_float_f_overflow_loop
        movlw   '*'
        rcall   L18_pf_outch
        decf    PF_FW,F,0
        bnn     L18_pf_float_f_overflow_loop
        bra     L18_pf_loop
        
L18_pf_float_f_range_chk2
        btfsc   _f1,7,0
        bra     L18_pf_float_f_overflow                
L18_pf_float_f_range_ok
        ICALL   F32toUI32                       ; f1 is now ui32

        movff   _f1+0,PREINC0
        movff   _f1+1,PREINC0
        movff   _f1+2,PREINC0
        movff   _f1+3,PREINC0

        rcall   L18_pf_restore_r                ; restore r4..r5+1         
        bra     L18_pf_int_is_positive          ; 32bit uint must be on stack

;; ------------- preload f1 and f2 with important float constants -------------------

;; these are so simple that this is implemented with individual mov/clr operations
;; rather than with a table

L18_pf_f2tenth                                  ; f2 = 0.1
        movlw   0x3d
        movwf   _f2+3,0
        movlw   0xcc
        movwf   _f2+2,0
        movwf   _f2+1,0
        movlw   0xcd
        movwf   _f2+0,0
        return  0
L18_pf_f2one                                    ; f2 = 1
        movlw   0x3f
        movwf   _f2+3,0
        movlw   0x80
        movwf   _f2+2,0
        bra     L18_pf_f2clr2
L18_pf_f2ten                                    ; f2 = 10
        movlw   0x20
        movwf   _f2+2,0
        movlw   0x41
        movwf   _f2+3,0
        bra     L18_pf_f2clr2
L18_pf_f2half                                   ; f2 = 0.5
        movlw   0x3f
        movwf   _f2+3,0
L18_pf_f2clr3
        clrf    _f2+2,0
L18_pf_f2clr2
        clrf    _f2+1,0
L18_pf_f2clr1
        clrf    _f2+0,0
        return  0
        
L18_pf_f1one                                    ; f1 = 1.0
        movlw   0x3f
        movwf   _f1+3,0
        movlw   0x80
        movwf   _f1+2,0
        bra     L18_pf_f1clr2
L18_pf_f1ten                                    ; f1 = 10
        movlw   0x20
        movwf   _f1+2,0
        movlw   0x41
        movwf   _f1+3,0
L18_pf_f1clr2
        clrf    _f1+1,0
        clrf    _f1+0,0
        return  0
               
;; ---------------------------- compare f1 with constants -------------------------

;; These constants are so simple that the compare operations are hard-coded.
;; This allows a minimum printf footprint is these routines are not needed otherwise.

;; check if f1 == 0 (incl. -0.0)
;;       TRUE:  W=0xff, Z=0
;;       FALSE: W=0x00, Z=1

L18_pf_f1zero
        movf    _f1+3,W,0
        andlw   0x70                            ; mask out sign
        iorwf   _f1+2,W,0
        iorwf   _f1+1,W,0
        iorwf   _f1,W,0
        bz      L18_pf_f1chk_true
        bra     L18_pf_f1chk_false
        
;; check if f1 >= 1
;;       TRUE:  W=0xff, Z=0
;;       FALSE: W=0x00, Z=1

L18_pf_f1ge1                                    
        rlcf    _f1+2,W,0
        rlcf    _f1+3,W,0                       ; exponent now in W
        addlw   256-0x7f
        bc      L18_pf_f1chk_true
L18_pf_f1chk_false
        andlw   0
        return  0
L18_pf_f1chk_true
        iorlw   0xff
        return  0

;; check if f1 < 10
;;      exp<0x41 -> TRUE
;;      exp>0x41 -> FALSE
;;      exp==0x41: only need to check highest mantissa byte because others 0x00

L18_pf_f1ltten
        rlcf    _f1+2,W,0
        rlcf    _f1+3,W,0                       ; exponent now in W
        addlw   -0x82
        bz      L18_pf_f1ltten_check_mant
        bn      L18_pf_f1chk_true
        bra     L18_pf_f1chk_false
L18_pf_f1ltten_check_mant
        movf    _f1+2,W,0                       ; get highest mantissa byte
        addlw   ~0x20                           ;   (exp bit7 is equal anyway)
        bnc     L18_pf_f1chk_true               ; is smaller
        bra     L18_pf_f1chk_false

;; --------------- code common to printf_float_f and printf_float_e ---------------

;; - get float from stack
;; - check sign and modify _r3
;; - flag format as 32bit in PF_OPTS
;; - move float to _f1 while saving _r3.._r5+1 on stack

L18_pf_float_handle_sign_r45
        movff   POSTDEC0,_f1+3                  ; copy float to _f1 (_r2, _r3)
        movff   POSTDEC0,_f1+2                  ;--> FP routine in RTL?
        movff   POSTDEC0,_f1+1
        movff   POSTDEC0,_f1+0
        bsf     PF_OPTS,0,0                     ; flag 32 bits
        bsf     PF_OPTS,1,0
        btfss   _f1+3,7,0                       ; test sign
        bra     L18_pf_float_f_pos
        bcf     _f1+3,7,0                       ; make positive
        lfsr    1,L18_pf_sign
        setf    INDF1,0                         ; flag negative for printing
L18_pf_float_f_pos
        ;bra    L18_pf_save_r                  ; back-up r4..r5+1 and return
        ;no bra needed since code follows below

; ------- save/restore _r4 .._r5+1 to/from backup area ---------

; used by floating point routines only, since these overwrite _r4.._r5+1
; uses FSR1 and FSR2, but this could be avoided...

L18_pf_save_r
        movff  PF_OPTS,L18_pf_opts
        movff  PF_PREC,L18_pf_prec
        movff  PF_FW,L18_pf_fw
        movff  PF_CURLEN,L18_pf_curlen
        return  0

L18_pf_restore_r
        movff  L18_pf_opts,PF_OPTS
        movff  L18_pf_prec,PF_PREC
        movff  L18_pf_fw,PF_FW
        movff  L18_pf_curlen,PF_CURLEN
        return  0
        
;; ----------------------- float exp format (%e) --------------------

;; algorithm for e:
;; - bring into 1-9.99 range by repeated multiplication and track exponent
;; - multiply by 10^precision
;; - add 0.5 for rounding
;; - convert to uint32
;; - check for overflow
;; - print with decimal inserted

;; potential improvements: for very large exponents, better multiply in larger
;; steps than single powers of 10 (e.g *= 10000 instead of *=10)
;; not sure if this is relevant at all

L18_pf_float_g
L18_pf_float_e
        tstfsz PF_PREC,0                        ; precision = 0 ?
        bra    L18_pf_float_e_prec_set          ; no, keep what is set
        movlw  -6
        addwf  PF_FW,W,0
        movwf  PF_PREC,0                        ; field width - 6
        btfsc   INDF0,7,0
        bra     L18_pf_float_e_prec_sign        ; negative
        movlw   0x80+0x40                       ; '+' or ' '
        andwf   PF_OPTS,W,0                     ; mask option bits
        bz      L18_pf_float_e_prec_set
L18_pf_float_e_prec_sign
        decf    PF_PREC,F,0                     ; one more character for sign
L18_pf_float_e_prec_set
        btfsc   PF_PREC,7,0
        clrf    PF_PREC,0                       ; set to 0 if negative
        movlw   7
        cpfsgt  PF_PREC,0                         
        bra     L18_pf_float_e_prec_ok          ; prec <= 7 -> ok
        movlw   7                               ; otherwise, limit to 7
        movwf   PF_PREC,0
        
L18_pf_float_e_prec_ok        
        rcall   L18_pf_float_handle_sign_r45
        clrf    PREINC0,0                       ; exp10 = 0
        rcall   L18_pf_f1zero                   ; special case 0.0, -0.0
        bnz     L18_pf_float_e_ok
        rcall   L18_pf_f1ltten                  ; f1 < 10?
        bnz     L18_pf_float_e_grow
        
L18_pf_float_e_shrink        
        rcall   L18_pf_f2tenth                  ; multiply by 0.1
        incf    INDF0,F,0
        ICALL   zfpmul32
        rcall   L18_pf_f1ltten
        bz      L18_pf_float_e_shrink        
        bra     L18_pf_float_e_ok
        
L18_pf_float_e_grow
        rcall   L18_pf_f1ge1
        bnz     L18_pf_float_e_ok
        rcall   L18_pf_f2ten                    ; multiply by 10
        decf    INDF0,F,0
        ICALL   zfpmul32
        bra     L18_pf_float_e_grow

L18_pf_float_e_ok                               ; exp10 correct, 1 <= val < 10
        movff   L18_pf_prec,PREINC0             ; push precision to TOS
L18_pf_float_e_prec_loop
        decf    INDF0,F,0       
        bn      L18_pf_float_e_prec_done        
        rcall    L18_pf_f2ten                   ; multiply by 10
        ICALL   zfpmul32
        bra     L18_pf_float_e_prec_loop
L18_pf_float_e_prec_done                
        movf    POSTDEC0,W,0                    ; pop precision counter 
                        
        rcall   L18_pf_f2half
        ICALL   zfpadd32
        ICALL   F32toUI32                       ; f1 is now uint32

        movf    POSTDEC0,W,0                    ; pop exponent
        
        movff    _f1+0,PREINC0                  ; move uint32 back to TOS
        movff   FSR0L,FSR1L                     ; FSR1 points to uint32
        movff   FSR0H,FSR1H                     
        movff    _f1+1,PREINC0
        movff    _f1+2,PREINC0
        movff    _f1+3,PREINC0

        clrf    PREINC0,0                       ; stop mark for spool
        rcall   L18_pf_push_exp                 ; push exp as ASCII
        movlw   'E'
        movwf   PREINC0,0                       ; 'E+xx' now on stack
        
        rcall   L18_pf_restore_r                ; restore r4..r5+1

        movlw   10
        movwf   _r0,0                           ; set base
        rcall   L18_pf_print_uint32_fsr1        ; print number

        movf    POSTDEC0,W,0                    ; remove from stack
        movf    POSTDEC0,W,0
        movf    POSTDEC0,W,0
        movf    POSTDEC0,W,0
        
        bra     L18_pf_loop

ENDIF

; ------------------------------------------------------------
;
; determines number of "fill" chars to arrive at field width
; L18_pf_calc_pad_size_no_sign     ignoring the sign char
; L18_pf_calc_pad_size             considers the sign char (+,-,' ')
;                                  depending on the options

L18_pf_calc_pad_size_no_sign
        clrf    _r0,0
        bra     L18_pf_calc_pad_size_cont
L18_pf_calc_pad_size
        rcall   L18_pf_sign_W
        clrf    _r0,0
        tstfsz  WREG,0
        incf    _r0,1,0
L18_pf_calc_pad_size_cont
        rcall   L18_pf_spool_size
        addwf   _r0,0,0                         ; w is now
        subwf   PF_FW,1,0                         ; PF_FW-w->PF_FW
        btfsc   PF_FW,7,0
        clrf    PF_FW,0                           ; PF_FW<0 -> 0
        return  0

; --------- write fill chars until >= field_width characters printed ----
;
; these can be '0' or ' '

L18_pf_pad_zeroes
        movlw   '0'
        bra     L18_pf_pad_start
L18_pf_pad_space
        movlw   ' '
L18_pf_pad_start
        movwf   PREINC0,0
L18_pf_pad_loop
        movf    PF_FW,W,0 ; field width
        cpfslt  PF_CURLEN,0 ; # chars printed in current field
        bra     L18_pf_pad_end
        movf    INDF0,W,0
        rcall   L18_pf_outch
        bra     L18_pf_pad_loop
L18_pf_pad_end
        movf    POSTDEC0,W,0
        return  0

; ---------------- spool out stacked characters --------------------

L18_pf_spool
        movf    POSTDEC0,W,0         ; check for stop mark
        bz      L18_pf_spool_end ; saves one return instruction
        rcall   L18_pf_outch
        bra     L18_pf_spool
L18_pf_spool_end
        return  0

; ----------------- determine spool length -------------------------
;
; W = number of characters

L18_pf_spool_size
        movlw   0
L18_spool_size_loop
        tstfsz  PLUSW0,0
        bra     L18_spool_size_cont
        negf    WREG,0
        return  0
L18_spool_size_cont
        addlw   -1
        bra     L18_spool_size_loop

IF 0

; ----- determine # of significant digits in spool buffer -----------
;
; W = number of significant digits
; FSR1 destroyed

L18_pf_spool_sig_digits
        movff   FSR0L,FSR1L
        movff   FSR0H,FSR1H
        clrf    PREINC0,0       ; digit counter, bit 7 = flag
L18_pf_spool_sig_digits_loop
        movf    POSTDEC1,W,0
        bz      L18_pf_spool_sig_digits_end
        addlw   255 - '9'
        addlw   ('9'-'1') + 1   ; check for '1'-'9'
        bc      L18_pf_spool_sig_digits_found
        btfss   INDF0,7,0
        bra     L18_pf_spool_sig_digits_loop
        addlw   1
        bnc     L18_pf_spool_sig_digits_loop
L18_pf_spool_sig_digits_found
        incf    INDF0,1,0
        bsf     INDF0,7,0
        bra     L18_pf_spool_sig_digits_loop
L18_pf_spool_sig_digits_end
        bcf     INDF0,7,0       ; remove flag
        movf    POSTDEC0,W,0
        return  0

ENDIF

; ----------------- determine how to print sign --------------------
;
; negative values: '-' always printed
; positive values: '+' or ' ' printed if corresponding flags set
;
L18_pf_sign_W
        lfsr    1,L18_pf_sign
        tstfsz  INDF1,0                         ; negative ?
        retlw  '-'                              ; yes
L18_pf_sign_W_pos
        btfsc   PF_OPTS,PF_OPT_PLUS,0                         ; '+' in format string?
        retlw   '+'
        btfsc   PF_OPTS,PF_OPT_SPC,0                         ; ' ' in format string?
        retlw   ' '
        retlw   0                               ; silent pos. sign

L18_pf_outsign
        rcall   L18_pf_sign_W                   ; determine sign char
        tstfsz  WREG,0
        bra     L18_pf_outch                    ; print if not zero
        return  0

; ----------------------------- print character ----------------------
;
; increments length counters of current field and total, preserves FSR1, _r4..._r5+1
; TBLPTR *must* be preserved by routine
; TODO: use print vector

L18_pf_outch  
        movff   FSR1L,PREINC0                   ; preserve FSR1
        movff   FSR1H,PREINC0
        lfsr    1,L18_pf_totlen
        incf    INDF1,1,0                       ; totlen++
        incf    PF_CURLEN,1,0                   ; curlen++

        lfsr    1,L18_pf_FMTMODE
        btfss   INDF1,7,0                       ; are we "s"printf'ing?
        bra     L18_pf_outch_pf                 ; no
        
        movff   L18_pf_STRPTR,FSR1L             ; "s"printf
        movff   L18_pf_STRPTR+1,FSR1H
        movwf   POSTINC1,0
        movff   FSR1L,L18_pf_STRPTR
        movff   FSR1H,L18_pf_STRPTR+1               
        bra     L18_pf_outch_end
        
L18_pf_outch_pf                                 ; regular "printf"
        movff   _r4,PREINC0                     ; save r4/r5 area
        movff   _r4+1,PREINC0
        movff   _r5,PREINC0
        movff   _r5+1,PREINC0
        movwf    PREINC0,0                      ; byte to print

        movff    L18_pf_outch_vec,PREINC0       ; output vector
        movff    L18_pf_outch_vec+1,PREINC0
        ICALL    indirect_call

        movf    POSTDEC0,W,0                    ; clean stack
        movff   POSTDEC0,_r5+1                  ; restore r4/r5 area
        movff   POSTDEC0,_r5
        movff   POSTDEC0,_r4+1
        movff   POSTDEC0,_r4
L18_pf_outch_end        
        movff   POSTDEC0,FSR1H                  ; restore FSR1
        movff   POSTDEC0,FSR1L
        return  0

;; ------- push exponent in W as ASCII to stack, incl. sign ---------
;; exponent is in W

IF PRINTF_FLOATS > 0

L18_pf_push_exp
        movwf   _r0,0                           ; save data
        movlw   '0'
        movwf   PREINC0,0                       ; 1s
        movwf   PREINC0,0                       ; 10s        
        movlw   -1
        btfsc   _r0,7,0                         ; test sign
        bra     L18_pf_push_exp_neg
        movlw   '+'
        bra     L18_pf_push_exp_sign
L18_pf_push_exp_neg
        negf    _r0,0                           ; negate value
        movlw   '-'
L18_pf_push_exp_sign        
        movwf   PREINC0,0                       ; sign (ASCII)
L18_pf_push_exp_loop
        movlw   9
        cpfsgt  _r0,0                           ; skip if _r0>9
        bra     L18_pf_push_exp_ok
        movlw   -1
        incf    PLUSW0,F,0                      ; increase 10s
        movlw   -10
        addwf   _r0,F,0                         ; _r0 -= 10
        bra     L18_pf_push_exp_loop
L18_pf_push_exp_ok                              ; copy back 1s
        movlw   '0'
        addwf   _r0,F,0
        movlw   -2
        movff   _r0,PLUSW0
        return  0

ENDIF


; ----- repetitively divide by base , push remainder ASCII-coded to stack.
; also, insert a '.' after # of digits specified by precision
; _r0:   base
; PF_OPTS:   flags, used to check whether hex a-f need to be capitalized
; PF_PREC: precision counter, is decremented and undefined upon exit
; FSR1:  points to first byte of 32 bit data

L18_pf_div_by_base_and_push
        clrf    _r0+1,0                         ; clear divisor high bytes
        clrf    _r0+2,0
        clrf    _r0+3,0
        movlw   -1                              ; adjust precision
        tstfsz   PF_PREC,0                      ; == 0 -> --
        movlw    1                              ;  > 0 -> ++
        addwf    PF_PREC,1,0
L18_pf_32bit_divloop
        ICALL   ipdiv32u                        ; *(FSR1) /= _r0_r1, mod -> _r2_r3
        movlw   '0'
        addwf   _r2,1,0                         ; add '0'-> r2; now ASCII except for hex
        movlw   255-'9'
        addwf   _r2,0,0                         ; >'9'?
        bnc      L18_pf_32bit_divloop_isdec
L18_pf_32bit_divloop_ishex
        movlw   'a'-'9'-1
        btfsc   PF_OPTS,PF_OPT_CAPS,0           ; hex chars in caps?
        movlw   'A'-'9'-1
        addwf   _r2,1,0
L18_pf_32bit_divloop_isdec
        movff   _r2,PREINC0                     ; push char to spool buffer
L18_pf_32bit_divloop_pastdec        
        decf    PF_PREC,1,0                     ; decrement precision counter
        bn      L18_pf_32bit_divloop_check_end
        decf    PF_PREC,0,0                     ; counter == 1 ? 
        movlw   '.'                             ; '.'
        bnz     L18_pf_32bit_divloop
        movwf   PREINC0,0                       ; yes, push '.' 
        bra     L18_pf_32bit_divloop_pastdec    
L18_pf_32bit_divloop_check_end
        movf    POSTINC1,W,0                    ; check if results > 0
        movf    POSTINC1,W,0
        movf    POSTINC1,W,0
        movf    POSTDEC1,W,0                    
        iorwf   POSTDEC1,0,0
        iorwf   POSTDEC1,0,0
        iorwf   INDF1,0,0
        bnz     L18_pf_32bit_divloop            ; yes -> continue
        return  0
X18_printf_
;<?cast8_32>
;<?cast16_32>
;<?neg32>
;<?ipdiv32u>
;<?popPTR>
;<?zfpmul32>
;<?zfpadd32>
;<?F32toUI32>
;<?indirect_call>
;<?L18_pf_static>
;<?L18_pf_static_float>
;<->

